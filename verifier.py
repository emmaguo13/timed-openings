import Crypto.Util.number, Crypto.Random, Crypto.Random.random
from mod import Mod
from utils.helpers import bitfield 

# todo: would be nice to have a class for everything the committer sends to the verifier
class Verifier: 
    # todo: get rid of the security parameter R here, use it in the full commitment scheme
    def __init__(self, R, N, bits, k=30): 
        self.R = R
        self.challenges = []
        self.N = N # broadcasted N
        self.bits = bits
        self.g = 0
        self.q_product = 1
        self.v = 0 
        self.k = k

    # todo: can probably clean this up
    # STEP 1 COMMIT: Receives h and g, verifies that g is constructed properly from h
    def verify_g(self, h, g_hat, q_array):
        # generate h in Z_N
        # generate set of all primes less than bound B
        print(q_array)
        print(self.bits)
        # compute g
        for q in q_array: 
            self.q_product *= q**self.bits
        
        print("q product", self.q_product)
        
        g = pow(h, self.q_product, self.N) 
        self.g = g
        print("g value", g)
        print("g_hat value", g_hat)
        if g == g_hat:
            return True 
        return False
    
    # STEP 1 ZKP: without commitment scheme 
    # We skip step 3 since the verifier never committed
    def gen_challenges(self, k): 
        self.k = k
        challenges = []
        for _ in range(k + 1):
            challenges.append(Crypto.Random.random.randrange(0, self.R, 1))
        self.challenges = challenges
        return challenges

    def verify_zkp(self, k, pairs, ys, W):
        zs = []
        z_hat = []
        for i in range(1, k + 1):
            zi = pairs[i][0]
            wi = pairs[i][1]

            zi_hat = pow(self.g, ys[i], self.N) * pow(W[i - 1], -self.challenges[i], self.N) % self.N
            if zi_hat != zi:
                print("bruh")
                print(zi_hat, zi, self.N)
                print(i)


                # print("HELLOOOOOOO")
                # print("a", As[i])
                # print("y", ys[i])
                # print("help", pow(2, pow(2, i - 1), self.q))
                return False

            zs.append(zi)
            z_hat.append(zi_hat)

            
            wi_hat = pow(W[i-1], ys[i], self.N) * pow(W[i], -self.challenges[i], self.N) % self.N

            if wi_hat != wi:
                return False
        self.W = W
        return True
    
    # ensures that v has odd order, and in the subgroup generated by g
    def compute_v(self, l, v_prime):
        self.v = pow(v_prime, self.q_product, self.N)
        # verify that v has odd order 
        v_check = pow(self.v, pow(2, l), self.N)
        assert(v_check == self.W[-1])
        return self.v

    # l is message length
    def open_message(self, l, S_seq):
        # compute pseudorandom sequence R
        self.l = l
        M_seq = []
        for i in range(l):
            exp = l - (i + 1)
            v_power = pow(self.v, pow(2, exp), self.N)
            v_power_bits = bitfield(v_power)
            M_i = v_power_bits[-1] ^ S_seq[i]
            M_seq.append(M_i)
        return M_seq
    
    def forced_compute_v(self, l):
        self.v = pow(self.g, pow(2, pow(2, self.k) - l), self.N)
        return self.v




